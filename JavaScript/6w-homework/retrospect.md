# 과제 수행 내용 및 회고
## 과제 수행 과정 기록
1. **데이터 성격 분류**
- 동적 상태값: 사용자의 클릭에 따라 변경되는 selected 클래스와 aria-pressed 속성을 상태 데이터로 분류함.

- 속성 데이터: 각 요금제의 정체성과 가격 정보를 HTML의 data-plan, data-price 속성에서 추출하여 활용함.

2. **명명 규칙 수립**
- 데이터 식별자: 텍스트가 삽입될 위치를 명확히 하기 위해 data-id="plan-name", data-id="plan-price"와 같은 사용자 정의 속성 규칙을 적용함.

- 상태 클래스: 활성화 상태를 직관적으로 나타내는 .selected와 노출 상태를 나타내는 .show를 사용함.

3. **가독성 최적화**
- 이벤트 위임(Event Delegation): 부모 컨테이너(.pricing-container) 하나에만 리스너를 등록하여 개별 버튼마다 리스너를 생성하는 번거로움을 없애고 메모리 효율을 높임.

- 메서드 체이닝 및 탐색: e.target.closest()를 활용해 클릭된 요소에서 필요한 상위 요소(.plan-card)와 하위 요소(.plan-selection-button)를 효율적으로 탐색함.

4. **실행 및 검증**
- null 체크: 요소 선택 실패 시 에러가 발생하지 않도록 if (!button) return과 같은 방어 코드를 작성함.

- 데이터 매칭: 클릭 시 card.dataset의 값이 하단 메시지 영역의 textContent로 정확히 전달되는지 콘솔 창을 통해 확인함.

---
## 과제 코드 리뷰
- querySelectorAll을 사용해 카드 전체를 찾아와 사용했고, 현재 클릭된 카드에는 selected 클래스를 추가하여 활성화를 시키고, forEach(반복처리문)를 활용해 클릭된 카드도 포함해 모든 카드의 selected 클래스를 반복적으로 제거.
- 요소 추출로 data *- 속성의 내용들도 dataset으로 활용.
---
## 회고(깨달은 점, 아쉬운 점 등)
base파일을 보면서 마크업에서 check-badge의 체크모양은 보더에 색을 넣고 효과를 추가해야되서 그런지 마크업으로 넣어두고, 컨텐츠 앞에 붙은 체크모양은 그저 색상만 변경하면 되서 ::before에서 content로 넣어서 사용한게 신기했다. 
또한 저번의 아코디언과 비슷하게 짧은 내용인데도 불구하고, data 속성들과 aria 속성들이 많이 들어가기도해서 컨텐츠 내용의 양과 마크업, CSS는 별개의 것이구나를 또 깨닫게 된다.
수업중 실습에서는 클래스는 .을 붙이고, data 속성들은 [data-name="data"] 이렇게 사용하다가 css의 추가 속성은 classList 속성 덕분에 . 없이 이름만 바로 사용해서 작성한 코드를 보면서도 뭔가 .이 없어서 어색하다는 느낌이 들었다. 
AI의 도움을 받아 작성한 코드 기준으로 부모요소에 한번만 걸기 위해 forEach 반복 리서드로 allCards에 반복을 거는 이유도 이해했고, 클릭된 요소에 css들이 적용되야해서 add랑 setAttribute한 이유도 이해가 갔는데, 솔직히 아직 저 dataset은 이해가 가지 않았다...이 부분은 데이터 속성 활용과 객체에 적용 이 내용을 아직 잘 이해 못한 것 같아서 집중 공부를 해야겠다.